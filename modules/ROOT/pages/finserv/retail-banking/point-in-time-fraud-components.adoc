= Point-in-Time Connected Components for Fraud Detection
:description: Master temporal fraud detection using point-in-time connected components to prevent future data leakage in real-time ML pipelines and ensure temporally consistent fraud network analysis.
:tags: point-in-time, connected-components, temporal-graphs, fraud-detection, wcc, fintech, retail-banking

== 1. Introduction

Financial institutions face the challenge of detecting sophisticated fraud networks that evolve over time, such as synthetic identity fraud rings and coordinated account takeover schemes. Traditional fraud detection approaches often struggle with temporal dependencies and can inadvertently introduce future data leakage, making them unsuitable for real-time machine learning applications.

The core business problem is ensuring accurate fraud detection while maintaining temporal consistency - preventing models from using information that wouldn't have been available at the time of the original transaction or application. This is critical for Buy-Now-Pay-Later services, retail banking applications, and any real-time fraud prevention system where decisions must be made instantly based only on historical data.

== 2. Scenario

Financial institutions encounter this challenge when building real-time fraud detection systems that require:

* *Real-time decisioning* without access to future information that could bias models
* *Consistent feature engineering* that respects temporal causality for machine learning pipelines
* *Dynamic fraud network detection* that adapts as criminal networks evolve over time
* *Regulatory compliance* requiring explainable models that don't use inappropriate temporal information

This scenario is particularly relevant for fintech companies offering instant credit decisions, traditional banks processing high-volume transactions, and any institution using machine learning for fraud prevention where model accuracy and temporal consistency are both critical.

== 3. Solution

Graph databases excel at modeling temporal relationships and computing connected components while preserving chronological order. Unlike traditional approaches that use static snapshots or introduce future leakage through standard weakly connected components algorithms, a temporal graph approach ensures that fraud network analysis respects the actual timeline of events.

=== 3.1. How Graph Databases Can Help

* *Temporal Modeling:* Graph databases can model events and relationships with precise timestamps, ensuring queries only access historically available information
* *Dynamic Connected Components:* Enable computation of fraud networks as they existed at any specific point in time, critical for consistent feature generation
* *Real-time Analysis:* Support instant querying of historical connectivity patterns without the computational overhead of rebuilding entire network snapshots

== 4. Modelling

This section demonstrates how to structure temporal connected components for fraud detection using Neo4j. The approach uses a simple yet powerful graph schema that maintains temporal consistency while enabling real-time fraud network analysis.

=== 4.1. Data Model

The base graph schema consists of the following nodes and relationships:

* *Nodes*:
  - `:User`: Represents actors (e.g., customers or fraudsters).
  - `:Event`: Represents time-stamped actions like applications, logins, or transactions.
  - `:Thing`: Represents shared resources such as IP addresses, phone numbers, devices, emails, bank accounts, or credit cards.
* *Relationships*:
  - `(:User)-[:COMMITS]->(:Event)`: Links a user to the event they triggered.
  - `(:Event)-[:WITH]->(:Thing)`: Links an event to the shared resources used.

We also introduce a relationship type to build a time-consistent spanning forest of the events and users.

  - `(:Event|User)-[:SAME_CC_AS]->(:Event)`: Chronological links forming a temporal connected component forest, ensuring time-respecting connectivity.

image::https://cdn-images-1.medium.com/max/1024/1*LTbw1WwV9QrInbSmxHblTQ.png[Model]

The structure forms a time-forest where leaves are users, inner nodes are events, and roots represent current connected components. This avoids cycles and preserves order.

=== 4.2. Demo Data

To demonstrate temporal connected components, use a dummy dataset. You can import it into Neo4j using the provided ZIP file from the reference repository.

1. Download the dataset ZIP: https://github.com/halftermeyer/temporal-connected-components-with-neo4j/blob/main/data-importer-dummy-dataset.zip[download]
2. Import via Neo4j Aura Console or Neo4j Desktop:
   - Select your instance and choose "Import".
   - Open the model with data and select the file.
   - Run the import.

Alternatively, generate sample data programmatically if needed.

Set parameters for queries:

[source, cypher, role=noheader]
----
:param {
  asOfDate: datetime('2024-07-10T20:00:00+02:00'),
  sample_size: 200,
  batch_min_size: 100,
  event_id: "e2ebf91fa-8542-4545-9599-5faa0f4950ac"
}
----

Create an index on event timestamps:

[source, cypher, role=noheader]
----
CREATE INDEX event_timestamp
IF NOT EXISTS
FOR (e:Event) ON (e.datetime)
----

Declare initial users as initial connected components:

[source, cypher, role=noheader]
----
MATCH (u:User)
CALL (u) {
  SET u:ConnectedComponent
} IN TRANSACTIONS OF 1000 ROWS
----

=== 4.3. Neo4j Schema

After importing the data, Neo4j interprets the graph schema. The temporal connected components model creates a time-forest structure where:

* Users are leaf nodes in the forest
* Events are inner nodes connecting users through shared resources
* The SAME_CC_AS relationships form the temporal spanning tree

[source, cypher, role=noheader]
----
// Show neo4j schema
CALL db.schema.visualization()
----

== 5. Cypher Queries

=== 5.1. Building the Temporal Structure

Process events chronologically to build the `:SAME_CC_AS` relationships.

image::https://cdn-images-1.medium.com/max/1024/1*RD7ibuhcco0G3Z7PEe6BRQ.png[Temporal Connected Component Forest]

First, project a GDS graph for efficient WCC computation (optional for batching - see https://neo4j.com/blog/developer/wcc-to-avoid-cypher-query-crashing/[this blog] for details):

[source, cypher, role=noheader]
----
CYPHER runtime=parallel
MATCH (thing:BankAccount|CreditCard|Device|EmailAddress|Event|IPAddress|PhoneNumber|Session|User)
CALL (thing) {
  MATCH (e:Event)-[:WITH|COMMITS]-(thing)
  WITH DISTINCT e
  WITH collect(e) AS events
  WITH CASE size(events)
    WHEN 1 THEN [events[0], null]
    ELSE events END AS events
  UNWIND range(0, size(events)-2) AS ix
  RETURN events[ix] AS source, events[ix+1] AS target
}
RETURN gds.graph.project(
  'wcc_graph', source, target, {});
----

Build the structure using GDS-driven batching:

[source, cypher, role=noheader]
----
CALL gds.wcc.stream('wcc_graph')
YIELD nodeId, componentId
WITH gds.util.asNode(nodeId) AS event, componentId
WITH componentId, collect(event) AS events
ORDER BY rand() //mixing CCs
CALL (events) {
  UNWIND events AS e
  WITH e
  WHERE NOT e:ConnectedComponent
  ORDER BY e.timestamp ASC
  CALL (e) {
    MATCH (e)(()-[:WITH]->(entity)<-[:WITH]-(:ConnectedComponent)){0,1}()<-[:COMMITS]-(p)
    WITH DISTINCT e, p
    MATCH (p)-[:SAME_CC_AS]->*(cc WHERE NOT EXISTS {(cc)-[:SAME_CC_AS]->()})
    MERGE (cc)-[:SAME_CC_AS]->(e)
    SET e:ConnectedComponent
  }
} IN CONCURRENT TRANSACTIONS OF 100 ROWS
----

Alternative query for building without GDS wcc-batching method:

[source, cypher, role=noheader]
----
CYPHER 5
MATCH (e:Event&!ConnectedComponent)
WITH e ORDER BY e.timestamp
CALL (e) {
  MATCH (e)(()-[:WITH]->(entity)<-[:WITH]-(:ConnectedComponent)){0,1}()<-[:COMMITS]-(u)
  WITH DISTINCT e, u
  MATCH (u)-[:SAME_CC_AS]->*(cc WHERE NOT EXISTS {(cc)-[:SAME_CC_AS]->()})
  MERGE (cc)-[:SAME_CC_AS]->(e)
  SET e:ConnectedComponent
} IN TRANSACTIONS OF 100 ROWS
----

=== 5.2. Querying Point-in-Time Connected Components

Retrieve all connected components as of a given date:

[source, cypher, role=noheader]
----
CYPHER 5 runtime=parallel
MATCH (cc:Event)
  WHERE cc.timestamp <= $asOfDate
  AND NOT EXISTS {
    (cc)-[:SAME_CC_AS]->(x:Event WHERE x.timestamp <= $asOfDate)
  }
RETURN cc
----

Get the connected component for a specific event ID with context:

[source, cypher, role=noheader]
----
CYPHER 5
MATCH p=(u:User)(()-[:SAME_CC_AS]->(ev))*(e:Event {event_id:$event_id})
UNWIND ev+[e] AS event
RETURN p, [(event)-[r:WITH]->(x)| [r, x]] AS with_things
----

=== 5.3. Detecting Non-Trivial Fraud Networks

Show non-trivial connected components:

[source, cypher, role=noheader]
----
MATCH (u:User)-[:SAME_CC_AS]->*(
  cc:ConnectedComponent WHERE NOT EXISTS {(cc)-[:SAME_CC_AS]->()}
)
WITH DISTINCT u, cc
WITH cc, collect(u) AS users
WITH cc, users, size(users) AS size
ORDER BY size DESC
WHERE size > 1
UNWIND users AS u
MATCH path=(u)-[:SAME_CC_AS]->*-(cc)
RETURN path, users, size
----

=== 5.4. Sample Dataset Generation

For generating a sample dataset without future leakage:

[source, cypher, role=noheader]
----
CYPHER 5
MATCH (e:Event)
WITH e, rand() AS r
ORDER BY r LIMIT $sample_size
WITH collect(e) AS events
UNWIND events AS e
WITH e ORDER BY e.timestamp ASC
MATCH (e)-[:COMMITS]-(u:User)
WITH e, u
// Additional logic for sampling without leakage
----

== 6. Graph Data Science (GDS)

=== 6.1. Temporal Weakly Connected Components

The temporal connected components approach can be enhanced using GDS algorithms for large-scale analysis while maintaining temporal consistency:

[source, cypher, role=noheader]
----
// Project temporal graph for GDS analysis
CALL gds.graph.project(
  'temporalFraudGraph',
  ['User', 'Event', 'Thing'],
  {
    COMMITS: {orientation: 'NATURAL'},
    WITH: {orientation: 'NATURAL'},
    SAME_CC_AS: {orientation: 'NATURAL'}
  },
  {
    nodeProperties: ['timestamp', 'event_id'],
    relationshipProperties: []
  }
)
----

=== 6.2. Streaming Connected Components

Compute and stream connected components for real-time fraud scoring:

[source, cypher, role=noheader]
----
// Stream WCC results for temporal fraud network analysis
CALL gds.wcc.stream('temporalFraudGraph')
YIELD nodeId, componentId
WITH gds.util.asNode(nodeId) AS node, componentId
WHERE node:User OR node:Event
RETURN node.event_id AS eventId, componentId, labels(node) AS nodeType
ORDER BY componentId
----

=== 6.3. Temporal PageRank Analysis

Identify central nodes in temporal fraud networks:

[source, cypher, role=noheader]
----
// Apply PageRank to identify central nodes in temporal fraud networks
CALL gds.pageRank.stream('temporalFraudGraph')
YIELD nodeId, score
WITH gds.util.asNode(nodeId) AS node, score
WHERE node:User
RETURN node AS userId, score
ORDER BY score DESC
LIMIT 20
----

This approach enables accurate, temporal-aware fraud ring detection in Neo4j, ideal for point-in-time WCC queries in fintech. It ensures ML features are computed without future leakage, improving fraud detection in real time.

References:

- https://neo4j.com/blog/developer/mastering-fraud-detection-temporal-graph/[original blog]
- https://github.com/halftermeyer/temporal-connected-components-with-neo4j/[code and toy dataset]
- https://neo4j.com/blog/developer/wcc-to-avoid-cypher-query-crashing/[wcc-batching blog]